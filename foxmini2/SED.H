/*========================================*/
/*                                        */
/*      THIS IS C   Total Library         */
/*                                        */
/*           "Initial Header"             */
/*                Module                  */
/*                                        */
/*     Programmed by Lee Kwang Chul       */
/*                                        */
/*     HITEL ID : fox8169 (Priend)        */
/*     TEL      : (062) 263-6669          */
/*                                        */
/*========================================*/

/* 컴파일 모델을 대형(LARGE)모델로 하지 않으면 에러메시지를 낸다. */
#ifndef __LARGE__
#error SED Ver 3.05 Only supports Large Model
#endif

#include <dos.h>

/*
   VGA 320*200, 256 Color Plane mode Graphic Kernel MACRO
   브가 320 곱하기 200 해상도 256색 평면 모드 그래픽 매크로 */

/* 사용자 정의(Users Type) */
#ifndef __USERS_TYPE
#define __USERS_TYPE
  typedef unsigned char BYTE;     /* BYTE 로 새로 정의 */
  typedef unsigned int  WORD;     /* WORD 로 새로 정의 */
  typedef unsigned long DWORD;    /* DWORD 로 새로 정의 */
#endif

/* addimg.c */
void imgHFill(WORD vseg,WORD voff,WORD fs,BYTE color);
void setStAdd(WORD startAddress);
void Hard_Scroll(WORD x,WORD y);    /* 하드웨어 스크롤 */
void setBitMask(BYTE mask,BYTE color);
void writeMode(BYTE mode); /* 브가 쓰기모드 결정 */

/* bar.c */
pImgFill_L(WORD offOfY,WORD x1,WORD vbpl,WORD x2,WORD ys,BYTE color);
void pImgFill(WORD offOfY,WORD x1,WORD vbpl,WORD x2,WORD ys,BYTE color);
void CBar(int x1,int y1,int x2,int y2,BYTE c);  /* 칠해진 박스 */

/* box.c */
void Box(int x1,int y1,int x2,int y2,BYTE c); /* 박스 그리기 */
void CBox(int x1,int y1,int x2,int y2,BYTE c);
void L_Box(int x,int y,int xl,int yl,BYTE c);
void CL_Box(int x,int y,int xl,int yl,BYTE c);

/* circle.c */
void Circle(int x0,int y0,int r,BYTE c); /* 원그리기 */
void CCircle(int x0,int y0,int r,BYTE c);
void Fill_Circle(int x0,int y0,int r,BYTE fc);
void CFill_Circle(int x0,int y0,int r,BYTE fc);
void Circle_Out(int x0,int y0,int r,BYTE fc);
void Border_Circle(int x0,int y0,int r1,int r2,int step,int c);

/* flood.c */
WORD Flood(int x,int y,BYTE fc,BYTE bc);
WORD Flood2(int x,int y,BYTE fc,BYTE ic);

/* hangul.c */
#define FONT_NUMBER 22   /* 폰트정의 색깔 갯수 */
extern BYTE font_color[FONT_NUMBER];  /* 폰트 칼라 배열 22개 */
extern int HANGUL_DELAY; /* 한글이 출력되는 속도를 조정 */
#define BEAU_FONT    0    /* 아름다운 한글 1 */
#define BEAU1_FONT   1    /* 아른다운 한글 2 */
#define BEAU2_FONT   2
#define NORMAL_FONT  3    /* 보통 글자 */

#define YES    1       /* 예     */
#define NO     0       /* 아니오 */

void puts_lee(int x, int y, char *s, int color, int flag, int choose);
void Printf_Han(int x, int y, int color, int ss, int font, char *format,...);
void Put_Han(int x, int y, int color, int ss, int font, int si, char *format,...);
char Input_String( int x, int y, char *data, BYTE color, BYTE back, char attr, char type, int number);

/* hvline.c */
void pImgHFill(WORD offOfY,WORD x1,WORD x2,BYTE color);
pImgHFill_L(WORD offOfY,WORD x1,WORD x2,BYTE color);
void CH_Line(int x1,int y1,int x2,BYTE c);
void pImgVFill(WORD offOfY,WORD XPos,WORD vbpl,WORD ys,BYTE color);
void CV_Line(int x1,int y1,int y2,BYTE c);

/* image.c */
extern BYTE COPY_MODE;    /* 0이면 자연스럽게 쓰기 1이면 덮어쓰기 */

void GetImg(WORD offOfY,WORD XPos,WORD vbpl,WORD xs,WORD ys,WORD dseg,WORD doff,WORD dbpl);
void pSprCp0_7(WORD sseg,WORD soff,WORD sbpl,WORD xs,WORD ys,WORD offOfY,WORD XPos,WORD vbpl,BYTE mode,BYTE copy_mm);
void pZoomSpr0123(WORD sseg,WORD soff,WORD sbpl,WORD xs,WORD ys,WORD offOfY,WORD XPos,WORD vbpl,WORD xl,WORD yl,BYTE mode, BYTE cc_mode);
void Spr_Mode(int x,int y,BYTE far *p,int xs,int ys,int m);
void ZSpr_Mode(int x,int y,BYTE far *p,int xs,int ys,int xz,int z,BYTE m);

/* keyintr.c */
extern char _key[128];              /* 멀티키 배열 */
extern BYTE _key_press;
extern char MULTI_KEY_FLAG;  /* 멀티키가 세트되어있는지 알아내는 전역변수 */

void Multi_Key();    /* 멀티키 세트 */
void Restore_Key();  /* 멀티키 끝 */
char Multi_Kbhit();  /* 멀티키에서 아무키나 눌려졌으면 1이 넘어온다. */
void Multi_Clear();  /* 멀티키 배열을 깨끗이 지운다. <아무키도 누르지 않는 상태로>

/* line.c */
void pVRAMSprCp(WORD voff,WORD scs,WORD xs,WORD ys,WORD mseg,WORD moff,WORD doff,WORD dcs);

/* mem.c */
void asmDecode(BYTE far *s,BYTE far *d,WORD l);
void mem2DCp(WORD sseg,WORD soff,WORD sbpl,WORD xs,WORD ys,WORD dseg,WORD doff,WORD dbpl);
void memCopy(WORD sseg,WORD soff,WORD tsize,WORD dseg,WORD doff);

/* mouse.c */
#define LB 0x1    /* 왼쪽 버튼   */
#define RB 0x2    /* 오른쪽 버튼 */
#define MB 0x4    /* 중간  버튼  */

#define NO_CLICK 0
#define OK_CLICK 1
#define END_CLICK 2

extern int M_X, M_Y, M_But;  /* 마우스좌표와 버튼상태 */

void Init_Mouse();    /* 마우스 드라이버를 초기화 한다. */
void Show_Mouse();    /* 마우스 포인터를 화면에 나타낸다. */
void Hide_Mouse();    /* 마우스 포인터를 화면에서 삭제한다. */
void Move_Mouse();    /* 마우스 포인터를 원하는 위치로 옮긴다. */
void Clip_Mouse(int, int, int, int);  /* 마우스가 활동할수 있는 영역을 설정 */
void Speed_Mouse(int, int);  /* 마우스의 움직이는 속도를 조종한다. */
void Read_Mouse();   /* 마우스의 X Y 좌표를 각각 mx와 my로 건네준다. */
char M_Click(int left,int top,int right,int bottom,int button);
/* 범위네에서 지정한 버튼이 눌리면 1이리턴 아니면 0이리턴 */

void Set_Mouse_Cursor(int *cursor );
void Set_Default_Cursor( int index );

/* music.c */
#define MDI        -1  /* MDI 화일임을 나타냄 */
#define RANDOM     -2

char Mus_Number(char *filename);      /* 합쳐져 있는 음악갯수를 알아낸다. */
void Mus_Play(char *fn, char number); /* 음악을 연주한다. */
void Mus_End();                       /* 음악을 끝낸다. */
extern char Mus_Continue;             /* 계속 연주할것인가 정의 */

/* page.c */
void Page_Line(int x1,int y1,int x2,int y2,int SourcePage,int TargetPage);
void CPage_Line(int x1,int y1,int x2,int y2,int SourcePage,int TargetPage);

#define Page_HLine(X1, Y1, X2, P, P1) Page_Line((X1),(Y1),(X2),(Y1),(P),(P1))
#define CPage_HLine(X1, Y1, X2, P, P1) CPage_Line((X1),(Y1),(X2),(Y1),(P),(P1))
#define Page_VLine(X1, Y1, Y2, P, P1) Page_Line((X1),(Y1),(X1),(Y2),(P),(P1))
#define CPage_VLine(X1, Y1, Y2, P, P1) CPage_Line((X1),(Y1),(X1),(Y2),(P),(P1))

void Page_Box(int x, int y, int x1, int y1, char page, char page1);
void CPage_Box(int x, int y, int x1, int y1, char page, char page1);
void Page_Circle(int x0,int y0,int r,char page, char page1);
void CPage_Circle(int x0,int y0,int r,char page, char page1);
void Page_FCircle(int x0,int y0,int r,char page, char page1);
void CPage_FCircle(int x0,int y0,int r,char page, char page1);
void Page_Tri(int x1,int y1,int x2,int y2,int x3,int y3,char page,char page1);
void CPage_Tri(int x1,int y1,int x2,int y2,int x3,int y3,char page,char page1);
void Page_FTri(int x1,int y1,int x2,int y2,int x3,int y3,char page,char page1);
void CPage_FTri(int x1,int y1,int x2,int y2,int x3,int y3,char page,char page1);

void Save_Page(int page);    /* 페이지를 저장한다. */
void Restore_Page(int page); /* 저장한 페이지 복구 */
void End_Page(int page);

/* palette.c */
#ifndef __PALETTE_STRUCT
#define __PALETTE_STRUCT
typedef struct {              /* 팔레트 구조체 선언 */
    BYTE red,green,blue;
} palette;
#endif

extern BYTE Img_Pal[768];  /* 압축을 풀기위한 전역 변수 */
extern Main_Pal[256];      /* MAIN 팔레트 */
extern char PALETTE_SET;   /* 팔레트를 바꿀것인지 정의 : DEFAULT : 1 */

void Wait_Snow();       /* 수직회괴중일때까지 기다린다. */
void Set_Palette();     /* 팔레트를 세트시킨다. 그림을 읽었을때 */
void Set_NPal(BYTE start, BYTE end, BYTE *pal);
void Get_NPal(BYTE start, BYTE end, BYTE *pal);
void Set_BPal(BYTE *pal);   /* 팔레트를 블록으로 세트한다. */
void Get_BPal(BYTE *pal);   /* 팔레트를 블록으로 읽는다.   */
void Set_RGB(BYTE palnum, BYTE red, BYTE green, BYTE blue);    /* 팔레트를 하나씩 세트한다. */
void Get_RGB(BYTE color, BYTE *red, BYTE *green, BYTE *blue);  /* 팔레트를 하나씩 읽는다. */
void Mix(BYTE *source, BYTE *target, BYTE mix);
void Mix_In(BYTE *target, BYTE speed);
void Mix_Out(BYTE *target, BYTE speed);
/* 처음번호 부터 끝 번호까지 밝기를 퍼센트로 조정  factor : 255  원래 밝기 */
void Fade(BYTE start, BYTE end, BYTE factor);
void Fade_In(BYTE start, BYTE end, BYTE speed);  /* 화면을 서서히 밝아지게 한다. */
void Fade_Out(BYTE start, BYTE end, BYTE speed); /* 화면을 서서히 어두어지게 한다. */
void Set_Gray(BYTE start, BYTE end, char mode);
void Load_Pal(char *file);     /* 팔레트를 화일에서 읽어온다. */
void Save_Pal(char *file);     /* 화일에 쓴다. */
void Load_APal(char *file, BYTE *pal);     /* 팔레트를 화일에서 읽어온다. */
void Save_APal(char *file, BYTE *pal);     /* 화일에 쓴다. */
void Set_Cycle_Alone();
void Restore_Cycle_Alone();
void Set_Cycle(BYTE start, BYTE end, BYTE delay_time);
void Rotate_Cycle(BYTE start, BYTE end, BYTE delay_time);
void Restore_Cycle();

#define Read_Pal() Get_BPal((void *)Main_Pal);

/* pixel.c */
void Pix_Put(WORD offOfY,WORD XPos,BYTE color);  /* 점찍기 */
void CPut_Pixel(int x,int y,BYTE c);
BYTE Get_Pix(WORD offOfY,WORD XPos);             /* 점 읽어오기 */

/* plane.c */
extern WORD far *_PPOFF[4] ;   /* 4 페이지 평면 모드 페이지 시작 어드레스 오프셑 */
extern WORD far *_POFF ;       /* 4 페이지 평면 모드 작업페이지 오프셑 포인터 */
extern WORD far  _PYOFF[800] ; /* 4 페이지 평면 모드 그래픽 좌표 오프셑 */
extern int  _XL,_YL,_XR,_YR ;  /* 자르기 창틀 구석 좌표값 */
extern WORD  _VBPL ;           /* 브가 비디오램 한줄당 바이트 수 */
extern WORD  _VBPP ;           /* 브가 비디오램 한화면당 바이트수 */
extern BYTE LogicFlag ;        /* VGA Internal Logical Fn Flag */
extern BYTE _tmpRGB[768] ;     /* termporary Palette Buffer */
extern WORD _VRAMSEG ;         /* Video RAM Segment */
extern BYTE _ET3000  ;         /* hardware panning Format */

void setMapMask(BYTE mask);
void Plane_Mode(void);       /* 유사 팩 모드에서 평면 모드로 전환 */
void Pack_Mode(void);        /* 유사 평면모드에서 팩 모드로 전환 */
void Set_Mode(char mode);    /* 모드 설정 */
void Vga_Plane();            /* 플레인모드로... */
void Text_Mode();            /* TEXT MODE 로... */
int Set_Xy(int width,int height);  /* 해상도 지정 */

/* poly_tri.c */
void Tri(int x1,int y1,int x2,int y2,int x3,int y3,BYTE color);  /* 삼각형 */
void CTri(int x1,int y1,int x2,int y2,int x3,int y3,BYTE color); /* 삼각형(클리핑) */
void Fill_Tri(int x1,int y1,int x2,int y2,int x3,int y3,BYTE color);
void CFill_Tri(int x1,int y1,int x2,int y2,int x3,int y3,BYTE color);
void Poly(int x[],int y[],int n,BYTE color);  /* 다각선 그리기 */
void CPoly(int x[],int y[],int n,BYTE color); /* 다각선 그리기(클리핑) */

/* rot_spr.c */
void Rot_Mode(int x,int y,BYTE *spr,int xs,int ys,int angle);

/* spr_pcx.c */
/* 스프라이트 헤더 선언 */
#define SPR_HEADER "Sprites Data File Ver 3.05\x1a"
#define OVL_HEADER "Over-Lap Data File Ver 3.05\x1a"

/* 헤더가 중복되는 걸 막기위해 */
#ifndef __SPRITE_STRUCT
#define __SPRITE_STRUCT
typedef struct {  /* 스프라이트 1개에 대한 구조체 변수 선언 */
    WORD size;   /* size - 4  실제 데이타 길이 */
    int x, y;    /* X 크기 Y 크기 */
    BYTE *image; /* 스프라이트 이미지 포인터 변수 */
}sprites;
#endif

/* <참고> PCX 화일형식은 라인 압축이다. 몇번과 그 다음줄 처음값이 같아도 압축을
   하지 않는다. 하지만 SED 는 그런게 없기때문에 압축효율이 더 좋다. */

extern BYTE *DECODE; /* 압축을 풀기위한 포인터 변수 */
char GActive_Page(); /* 작업 페이지를 알아낸다. */

char Decode_Init(BYTE msize); /* 압축을 풀기위한 배열을 잡는다. */
/* msize * 1000  예:Decode_Init(64);  64000바이트만큼 배열을 잡는다. */
/* Pcx 화일을 열때 64  보통을 64*64 = 4096  Decode_Init(5) */
/* 실패하면 -1이 넘어온다. */

void Decode_End();   /* DECODE 에 할당된 메모리 복구 */

void Decode_Data(sprites *data); /* 압축을 푸는 함수 */
void Incode_Data(sprites *data); /* 압축을 하는 함수 */
void Incode_Pcx(sprites *Buff);  /* PCX 화일로 압축할때 쓰인다. */

void Decode_Spr(int start, int end, sprites *Spr, char msize); /* 번호로 압축을 푼다. */
void Incode_Spr(int start, int end, sprites *Spr, char msize); /* 번호로 압축을 한다. */

char Get_Rle(sprites *Spr); /* 압축이 되어있는지 알아내는 함수 */
                            /* 압축 : 1, 압축안됨 : 0 이넘어온다. */

/* 압축된 그대로 스프라이트를 읽는다. */
char Load_Spr(int Start, int End, char *sprfile, sprites *Spr);
void Save_Spr(int Start, int End, char *sprfile, sprites *Spr);
int Spr_Number(char *sprfile);   /* 스프라이트의 갯수를 건네준다. */

void Free_Spr(int Start, int End, sprites *Spr); /* 메모리 복구 */
void Free(sprites *Spr);   /* 낱개로 복구한다. */

/* 확대를 해서 화면에 찍는다. */
/* 주의 : 압축을 풀어서 찍어야 한다. */
/* 예 : Decode_Data(sprites *Buff); */
/* ZPut_Spr(x,y,*Buff,xs,ys,mode); */
void ZPut_Spr(int x, int y, sprites *Buff, int xs, int ys, BYTE mode);
void ZCPut_Spr(int x, int y, sprites *Buff, int xs, int ys, BYTE mode);

/* 그냥 화면에 찍는다. */
void Put_Spr(int x, int y, sprites *Buff, BYTE mode);
void CPut_Spr(int x, int y, sprites *Buff, BYTE mode);

/* x,y xs,ys 의 가운데서 확대를 한다. */
void CZPut_Spr(int x, int y, sprites *Buff,int xs,int ys,unsigned char mode);
void DZPut_Spr(int x, int y, sprites *Buff,int xs,int ys,unsigned char mode);
void Rot_Spr(int x, int y, sprites *Buff, int angle);

/* 압축을 풀어서 화면에 찍는다. */
/* 원래 이미지는 그대로 있다. 압축된 상태로 */
void RZPut_Spr(int x, int y, sprites *Buff, int xs, int ys, unsigned char mode);
void RPut_Spr(int x, int y, sprites *Buff, unsigned char mode);

void Get_Spr(int x, int y, sprites *Buff, int xs, int ys);
void RGet_Spr(int x, int y, sprites *Buff, int xs, int ys);

char Load_Pcx(char *pcxfile, sprites *Buff);  /* PCX 화일을 읽는다. */
void Save_Pcx(char *pcxfile, sprites *Buff);
/* 예 : Load_Pcx("화일이름",&Pcx[0]); */
/* RPut_Spr(x,y,&Pcx[0],mode); */

char Load_Cel(char *celfile, sprites *Buff);  /* CEL 화일을 읽는다. */
void Save_Pcx(char *celfile, sprites *Buff);

char Load_Sed(char *sedfile, sprites *Buff);  /* SED 화일을 읽는다. */
void Save_Pcx(char *sedfile, sprites *Buff);

char Load_Ovl(char *ovlfile, sprites *ovb, BYTE *pal, BYTE *pal1);
void Save_Ovl(char *ovlfile, sprites *ovb, BYTE *pal, BYTE *pal1);

/* 모자이크 기법 */
void Mojaik(int x,int y,sprites *mojaik, BYTE zoom);
void CMojaik(int x,int y,sprites *mojaik, BYTE zoom);

/* text.c : 텍스트 함수 */
void Text_Open(int delay);
void Text_Close();

/* util.c : 쓸만한 유틸리티 */
#define ON  1             /* 모니터 상태 켬 */
#define OFF 0             /* 모니터 상태 끔 */

void Delay(WORD milli_sec);  /* 1/1000 초단위로 기다린다. */
void Monitor(char onoff);    /* 모니터를 켜고 끈다. */
int Get_Key();     /* 키를 입력 받는다. */
int Action_Key();  /* 키를 실시간으로 입력 받는다. */
void Char_To_Int( char char_high, char char_low, int *integer );
void Int_To_Char( int integer, char *char_high, char *char_low );
void Get_Path( char *path );
char *str( int number );
char File_Exist(char *filename);   /* 화일이 있는지 알아내는 함수 */

/* voice.c : 음성 출력 */
#define Sample setSampleRate     /* 음성 샘플링 */
#define Volume setPCMVolume

#define VOC        -1            /* VOC 화일임을 나타냄 */

extern int VoiceFlag  ;   /* 음성 출력 상테 변수 */
extern int SBLBaseIO ;     /* default sound blaster Base IO Address */
extern int SBLIRQ ;        /* default sound blaster hardware interrupt */
extern int SBLDMAChannel ; /* default sound blaster DMA channel */
extern int CovoxIO ;       /*  코복스 포트번호 칼라어댑터 병렬 포트 1 */
extern WORD SampleRate ;
extern BYTE MultiVoice ;

/* 음성 출력 하드웨어 정의 */

#define NO_VOICE      0 /* 음성 출력을 하지 않는다. */
#define SOUNDBLASTER  2 /* 사운드 블래스터 */
#define PC_SPEAKER    1 /* 피시 스피커 */
#define COVOX         3 /* 코복스 */

#define VOICE_IDLE 0    /* 음성 출력중이 아니다. */
#define VOICE_BUSY 1    /* 음성 출력중이다. */

/* 음성을 출력한다. */
#define Voice_Say(F, S) sayPCM((BYTE *)(F),(char)S,0)

/* 음성 출력이 끝날때 까지 기다린다. */
#define Wait_Voc()    while(VoiceFlag==VOICE_BUSY)
#define Wait_Voc_Key()  while(!kbhit()) while(VoiceFlag==VOICE_BUSY) break;

void Voice_End(void) ;          
int Voice_Init(int SndDev);  /* 주변장치 초기화 */
int Voice_Silent(int flag);  /* 음성을 강제로 중단. */
void setSoundBlasterENV(int BaseIO,int IRQ,int DMAChannel);  /* 사운드 블래스터 초기화 */
int SB_Check(void);          /* 사블이 있는지 체크한다. */

/* win_box.c : 원도우 박스 */
void Box_3d(int x1, int y1, int x2, int y2, BYTE color, BYTE color1);
void CBox_3d(int x1, int y1, int x2, int y2, BYTE color, BYTE color1);
void Win_3d( int x1, int y1, int x2, int y2, BYTE s, BYTE s1,BYTE s3, BYTE q);
void Box_3dB(int x1, int y1, int x2, int y2, BYTE s, BYTE s1, BYTE s2);
void CBox_3dB(int x1, int y1, int x2, int y2, BYTE s, BYTE s1, BYTE s2);
void Win_3dB( int x1, int y1, int x2, int y2, BYTE s, BYTE s1,BYTE color, BYTE q, BYTE q1);
void CWin_3dB( int x1, int y1, int x2, int y2, BYTE s, BYTE s1,BYTE color, BYTE q, BYTE q1);
void Box_Beau(int x, int y, int x1, int y1, int mm, BYTE color);
void Xor_Pixel(WORD x, WORD y, BYTE color);
void Xor_CPixel(WORD x, WORD y, BYTE color);
void Xor_HLine(int x, int y, int x1, BYTE color);
void Xor_CHLine(int x, int y, int x1, BYTE color);
void Xor_VLine(int x, int y, int y1, BYTE color);
void Xor_CVLine(int x, int y, int y1, BYTE color);
void Xor_Box(int x, int y, int x1, int y1,BYTE color);
void Xor_CBox(int x, int y, int x1, int y1,BYTE color);
void Put_Msg(BYTE y, char *string, BYTE win_color, BYTE color, BYTE wait_time);
BYTE Yes_No(BYTE y, char *string, BYTE win_color, BYTE color, char sub,char yes_no);

#define _SCAN400LINE 0x1 /* 400 줄 스켄 라인 */
#define _SCAN350LINE 0x2 /* 350 줄 스켄 라인 */
#define _SCAN480LINE 0x3 /* 480 줄 스켄 라인 */

#define _CLOCK25MHZ  0x0 /* 25 MHZ DOT CLOCK */
#define _CLOCK28MHZ  0x1 /* 28 MHZ DOT CLOCK */

#define _SCREEN_ON   0x0 /* 화면 표시 ON */
#define _SCREEN_OFF  0x1 /* 화면 표시 OFF */

#define setLogic()   (LogicFlag=1)
#define resetLogic() (LogicFlag=0)

#define _PSET  0x00      /* 브가 내부 논리함수가 직접 쓰기 */
#define _PAND  0x08      /* 브가 내부 논리함수가 AND  쓰기 */
#define _POR   0x10      /* 브가 내부 논리함수가 OR   쓰기 */
#define _PXOR  0x18      /* 브가 내부 논리함수가 XOR  쓰기 */

/* 다음에 선언이 되어 있는 매크로는 4 페이지 평면모드  전용임 */

/* 화면에 보이는 페이지 설정 */
#define View_Page(P)          setStAdd(*_PPOFF[(P)])

/* 작업 페이지 설정 두개의 함수가 똑같음, 사용하기 쉽게 */
#define Work_Page(P)         _POFF = _PPOFF[(P)]
#define Active_Page(P)       _POFF = _PPOFF[(P)]

/* 다중 페이지를 이용한 에니메이션 매크로 */
#define Animate(P)          { View_Page(P) ; P = (P+1)%2 ; Active_Page(P) ; }

/* 현재 작업  화면 지우기 */
#define Work_Clear(C)           { setMapMask(0xf) ; imgHFill(_VRAMSEG,_POFF[0],_VBPP,(C)) ; }
#define Active_Clear(C)         { setMapMask(0xf) ; imgHFill(_VRAMSEG,_POFF[0],_VBPP,(C)) ; }

/* 페이지 화면 지우기 */
#define Page_Clear(P,C)       { setMapMask(0xf) ; imgHFill(_VRAMSEG,(*_PPOFF[(P)]),_VBPP,(C)) ; }
/* 클리핑 화면 지우기 */
#define CPage_Clear(C)           CBar(_XL,_YL,_XR,_YR,(C))

/* 페이지에서  페이지로 화면 복사하기 */
#define Page_Copy(S,D)     { setMapMask(0xf) ; writeMode(1) ; memCopy(_VRAMSEG,(*_PPOFF[S]),_VBPP,_VRAMSEG,(*_PPOFF[D])) ; writeMode(0) ; }

/* 좌표에 한점 찍기 */
#define Put_Pixel(X,Y,C)         Pix_Put(_POFF[(Y)],(X),(C))

/* 좌표에 찍힌 점 색깔 얻어오기 */
#define Get_Pixel(X,Y)           Get_Pix(_POFF[(Y)],(X))

/* 사각형 칠해서 그리기 ( 그리는 구석 좌표와 길이 ) */
#define L_Bar(X,Y,XL,YL,C)   pImgFill(_POFF[(Y)],(X),_VBPL,(XL)+(X)-1,(YL),(C))
/* 사각형 칠해서 그리기 ( 그리는 양 구석의 좌표로 ) */
#define Bar(X1,Y1,X2,Y2,C) pImgFill(_POFF[(Y1)],(X1),_VBPL,(X2),(Y2)-(Y1)+1,(C))

/* 상자 그리고 칠하기 */
#define CL_Bar(X,Y,XL,YL,C)   CBar((X),(Y),(X)+(XL)-1,(Y)+(YL)-1,(C))

/* 수평선 그리기 ( 좌표와 길이로 ) */
#define HL_Line(X,Y,L,C)     pImgHFill(_POFF[(Y)],(X),(X)+(L)-1,(C))
/* 수평선 그리기 ( 한점과 길이로 ) */
#define H_Line(X1,Y,X2,C)   pImgHFill(_POFF[(Y)],(X1),(X2),(C))

/* 한점과 길이로 수평선 그리기 */
#define CHL_Line(X,Y,L,C)     CH_Line((X),(Y),(X)+(L)-1,(C))

/* 수직선 그리기 ( 좌표와 길이로 ) */
#define VL_Line(X,Y,L,C)     pImgVFill(_POFF[(Y)],(X),_VBPL,(L),(C))
/* 수직선 그리기 ( 양끝 좌표로 ) */
#define V_Line(X,Y1,Y2,C)   pImgVFill(_POFF[(Y1)],(X),_VBPL,(Y2)-(Y1)+1,(C))

/* 수직선 그리고 칠하기 */
#define CVL_Line(X,Y,L,C)     CV_Line((X),(Y),(Y)+(L)-1,(C))

/* 비트맵 찍기 
#define  Put_Bitmap(X,Y,P,XL,YL,C) pBitImgCp(FP_SEG(P),FP_OFF(P),XL,YL,_POFF[Y],X,_VBPL,C)
#define  ZPut_Bitmap(X,Y,P,XL,YL,XZ,YZ,C) \
         pZoomOutBitImgCp(FP_SEG(P),FP_OFF(P),XL,YL,_POFF[Y],X,_VBPL,C,XZ,YZ)
#define  FPut_Bitmap(X,Y,P,XL,YL,C) pFBitImgCp(FP_SEG(P),FP_OFF(P),XL,YL,_POFF[Y],(X)/4,_VBPL,C)
*/

/* 화면상의 그림 잡아오기 */
#define Get_Image(X,Y,P,C,R)   GetImg(_POFF[(Y)],X,_VBPL,C,R,FP_SEG(P),FP_OFF(P),C)

/*
   스프라이트를 그리기 매크로
   X,Y 좌표
   P 스프라이트 포인터
   C,R 스프라이트 가로세로 크기
   M 그릴 모드
    0 : 바로그리기        4 : 90도 회전
    1 : 좌우 대칭         5 : 90도 회전 좌우대칭
    2 : 상하 대칭         6 : 90도 회전 상하대칭
    3 : 상하좌우 대칭     7 : 90도 회전 상하좌우 대칭
*/

#define Put_Image(X,Y,P,C,R,M)  pSprCp0_7(FP_SEG(P),FP_OFF(P),C,C,R,_POFF[Y],X,_VBPL,(M),(COPY_MODE))

/*
   스프라이트를 확대 축소하여 그리기 매크로
   X,Y 좌표
   P 스프라이트 포인터
   C,R 스프라이트 가로세로 크기
   XZ,YZ 확대 배율 ( 32가 실제 배율 1 임)
   M 그릴 모드
    0 : 바로그리기
    1 : 좌우 대칭
    2 : 상하 대칭
    3 : 상하좌우 대칭
*/
#define ZPut_Image(X,Y,P,C,R,XL,YL,M) pZoomSpr0123(FP_SEG(P),FP_OFF(P),C,C,R,_POFF[Y],X,_VBPL,XL,YL,(M),(COPY_MODE))

/* 클리핑 창틀 설정 */
#define Set_Clip(X1,Y1,X2,Y2)  { _XL=(X1) ; _YL=(Y1) ; _XR=(X2) ; _YR=(Y2) ; }
#define View_Clip(C)  Box(_XL-1,_YL-1,_XR+1,_YR+1,C)
#define Box_Fill Bar    /* 칠해진 박스를 그리는 함수 */
#define CBox_Fill CBar  /* 칠해진 박스를 그리는 함수 */

#define GRAY  1  /* 흑백 모드 */
#define COLOR 0  /* 칼라 모드 */

/* 일반키와 확장키 정의 */
#define ESC    0x1b
#define ENTER  0x0d
#define SPACE  0x20

#define LEFT   0x4b00
#define RIGHT  0x4d00
#define UP     0x4800
#define DOWN   0x5000
#define HOME   0x4700
#define END    0x4f00
#define PgUp   0x4900
#define PgDn   0x5100
#define INS    0x5200
#define DEL    0x5300
#define ALT    0x0800

#define ALT_X  0x2d00

/* 멀티키 정의 부분 */

#define _ESC       1
#define _F1        59
#define _F2        60
#define _F3        61
#define _F4        62
#define _F5        63
#define _F6        64
#define _F7        65
#define _F8        66
#define _F9        67
#define _F10       68
#define _F11       87
#define _F12       88

#define _ALT       56
#define _CTRL      29
#define _TAB       15
#define _BP        14
#define _SPACE     57
#define _ENTER     28
#define _UP        72
#define _DOWN      80
#define _LEFT      75
#define _RIGHT     77
#define _HOME      71
#define _END       79
#define _PGUP      73
#define _PGDN      81
#define _INS       82
#define _DEL       83
#define _LSHIFT    42
#define _RSHIFT    54
#define _SLOCK     70
#define _PRTSCR    55

#define _A  30        
#define _B  48
#define _C  46
#define _D  32
#define _E  18
#define _F  33
#define _G  34
#define _H  35
#define _I  23
#define _J  36
#define _K  37
#define _L  38
#define _M  50
#define _N  49
#define _O  24
#define _P  25
#define _Q  16
#define _R  19
#define _S  31
#define _T  20
#define _U  22
#define _V  47
#define _W  17
#define _X  45
#define _Y  21
#define _Z  44 













