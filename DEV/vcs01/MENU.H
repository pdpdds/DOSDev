/*************************************************************/
/* menu.h : x_menu(), y_menu(), dialog_box() 함수 정의       */
/*************************************************************/

#include  "chulryuk.h"   /* normal(), reverse(), set_attrib()*/
#include  "ibryuk.h"     /* get_key(), xy_vgets()            */

/*************************************************************/
/* 함수값 : 선택된 메뉴에 대한 숫자(첫번째->0, 두번째->2,...)*/
/* Esc 키       : 함수 종료, 함수값 => -1                    */
/* flag[0]=='L' : LEFT/RIGHT 키를 누른경우 실행종료.         */
/*                함수값은 LEFT/RIGHT(331/333)               */
/* flag[0]!='L' : LEFT/RIGHT 키를 누른경우 삑 소리만 울린다  */
/* flag[1]=='C' : 함수 실행 종료시 메뉴판을 지운다(Clear)    */
/* flag[1]!='C' : 함수 실행 종료시 메뉴판을 지우지 않는다    */
/*************************************************************/
int y_menu(int x, int y, int suntaek, char *flag, char **menu, int chuga)
    {
    int    n     = 0;    /* menu의 항목 개수가 구해진다      */
    int    chdae = 0;    /* menu의 항목중 최대 길이의 문자수 */
    char   buf[4000];    /* 메뉴판 부분의 이전 내용 보관용   */
    int    i;

       set_cursor(32,0);
    
    /*  menu 항목의 갯수(n), 최대 길이(chdae)를 구한다 */
    while (menu[n][0] != '.')
	{
	if (strlen(menu[n]) > chdae)
	    chdae = strlen(menu[n]);
	n++;
	}

    /* 메뉴판으로 사용할 사각형 내부의 종전 내용을 보관 */
    gettext(x, y, x+chdae+6,y+2+n, buf);

    /* 메뉴판으로 사용할 사각형 내부만을 지운다 */
    window(x+2, y+1, x+chdae+6,y+2+n);
    clrscr();
    window(x ,y ,x+chdae+3,y+1+n);
    textattr(0x70);
    clrscr();
    window(1,1, 80,25);
    single_box(x, y, x+chdae+3,y+1+n);
   
   for (i=0 ; i<n ; i++)
        xy_puts(x+3, y+1+i, menu[i]);

    /* 이전에 선택된 menu 항목을 반전 상태로 표시 */
    xy_puts(x+3, y+1+suntaek, menu[suntaek]);
    set_attrib(x+1, x+chdae+2, y+1+suntaek, 0x2f);

    /* 엔터/ESC 키를 누르면 종료된다 */
    while ( 1 )
	{
	  if(chuga==0 && suntaek==0)
           xy_puts(5,25,"뭼  젌퀛첊(person2.dat)첂 씨찌 燭 젌챹 쌰");
	   else if(chuga==0 && suntaek==1)
            xy_puts(5,25,"뭼  쨬첲칲 썖,쩠촋                           ");
	    else if(chuga==0 && suntaek==2)
             xy_puts(5,25,"뭼  잋컠왠좾탺(쌱 잋컠왠첂 쩢좾) 防            ");
	     else if(chuga==0 && suntaek==3)
              xy_puts(5,25,"뭼  浩핎 잋컠왠 왘찌 燭 젌 育            ");
	      else if(chuga==0 && suntaek==4)
               xy_puts(5,25,"뭼  A: 왠윕첇쥙 젌퀛첊(person2.dat)챹 짉쮱     ");
	       else if(chuga==0 && suntaek==5)
                xy_puts(5,25,"뭼  The End                                        ");
          if(chuga==1 && suntaek==0)
           xy_puts(5,25,"뭼  왩핏 젏왢 젌챹 줮찔촿얦얯.    ");
          else if(chuga==1 && suntaek==1)
           xy_puts(5,25,"뭼  첔쟞  줮찔촿얦얯.               ");  
           else if(chuga==1 && suntaek==2)
            xy_puts(5,25,"뭼  찔첔쟞 줮찔촿얦얯.                ");

          if(chuga==2 && suntaek==0)
           xy_puts(5,25,"뭼  쨬챶 썖颱촿얦얯.                                ");
           else if(chuga==2 && suntaek==1)
            xy_puts(5,25,"뭼  찣쟍왤절, 첇쟎첇 '쐕'첉 帽昰 칚얙얯왢쵔             ");
            else if(chuga==2 && suntaek==4)
             xy_puts(5,25,"뭼  찣쟍왤절, '캮쏮'쟞 썖颱홊℉瑁, '썴썂'쟞 썖颱홊℉瑁");
             else if(suntaek==7)
              xy_puts(5,25,"뭼  찣쟍왤절, '쨠'찌 募 帽馝 썖颱 웒              ");
              else if(suntaek==8)
               xy_puts(5,25,"뭼  찣쟍왤절, '쨬쥂쏮'찌 募 帽馝 썖颱 웒            ");
	       else if(suntaek==11)
                xy_puts(5,25,"뭼  찣쟍왤절, 쵕천첇 '쨠'첉 帽馝 썖颱 웒            ");
                else if(suntaek==12)
                 xy_puts(5,25,"뭼  찣쟍왤절, 쵕천첇 '쨬쥂쏮'첉 帽馝 썖颱 웒          ");
                 else if(chuga==2)
                  xy_puts(5,25,"뭼  챴쾖쨬첐얙 썖汰 촿얦얯.                            ");
          if(chuga==3 && suntaek==0)
           xy_puts(5,25,"뭼  홏 첋쮩 줮쨮.");
           else if(chuga==3 && suntaek==1)
            xy_puts(5,25,"뭼  척훶           ");

        switch ( get_key() )
	    {
	    case UP   : set_attrib(x+1,x+chdae+2, y+1+suntaek, 0x70);
			if (suntaek == 0)   suntaek = n-1;
			else                suntaek--;
                        set_attrib(x+1,x+chdae+2, y+1+suntaek, 0x2f);
			break;
	    case DOWN : set_attrib(x+1,x+chdae+2, y+1+suntaek, 0x70);
			if (suntaek == n-1) suntaek = 0;
			else                suntaek++;
                        set_attrib(x+1,x+chdae+2, y+1+suntaek, 0x2f);
			break;
	    case LEFT : if (flag[0] == 'L')
			    {
			    if (flag[1] == 'C')
				puttext(x, y,x+chdae+6,y+2+n, buf);
			    return ( LEFT );
			    }
			putch('\a'); break;
	    case RIGHT: if (flag[0] == 'L')
			    {
			    if (flag[1] == 'C')
				puttext(x, y,x+chdae+6,y+2+n, buf);
			    return ( RIGHT );
			    }
			putch('\a'); break;
	    case ESC  : if (flag[1] == 'C')
			    puttext(x, y,x+chdae+6,y+2+n, buf);

			return ( -1 );
	    case CR   : if (flag[1] == 'C')
			    puttext(x, y,x+chdae+6,y+2+n, buf);
			normal();
			set_cursor(12,13);
			return ( suntaek );
            default   :  break;
	    }
	}
    }

/*************************************************************/
/* 함수값 : 선택된 메뉴에 대한 숫자(첫번째->0, 두번째->2,...)*/
/* Esc 키       : 함수 종료, 함수값 => -1                    */
/* flag[0]=='D' : DOWN 키를 누른경우 실행 종료.              */
/* flag[0]!='D' : DOWN 키를 누른경우 삑 소리만 울린다        */
/* flag[1]=='S' : 메뉴판을 표시후 메뉴를 선택하게 한다       */
/* flag[1]!='S' : 메뉴판을 표시만 한후 실행 종료             */
/*************************************************************/
int x_menu(int x, int y, int suntaek, char *flag, char **menu)
    {
    int    n     = 0;        /* menu의 항목 개수가 구해진다  */
    int    chdae = 0;        /* menu의 항목중 최대 길이      */
    int    x_jwapyo[20];     /* 각 menu 항목을 표시할 x 좌표 */
    int    pok;              /* 각 항목의 메뉴행 상에서의 폭 */
    int    i, giri;

     set_cursor(32,0);

    /* menu 항목의 갯수(n), 최대 길이(chdae)를 구한다 */
    while (menu[n][0] != '.')
	{
	if ( (giri=strlen(menu[n])) > chdae )
	    chdae = giri;
	n++;
	}
    pok = chdae+1;

    /* 메뉴행에 밑줄을 그린다 */



    /* 각 메뉴 항목을 표시 */
    for (i=0 ; i<n ; i++)
	{
	giri        = strlen(menu[i]);
	x_jwapyo[i] = x+pok*i+(pok-giri)/2;
	xy_puts(x_jwapyo[i], y, menu[i]);
	}

    if (suntaek == -1)  return (-1);

    /* 이전에 선택된 menu항목을 반전 상태로 표시 */
    textattr(0xcf);
    xy_puts(x_jwapyo[suntaek], y, menu[suntaek]);
    normal();

    if (flag[1] != 'S')
      { set_cursor(12,13); return ( suntaek ); }

    /* 엔터/ESC 키를 누르면 종료된다 */
    while ( 1 )
	{
	  textattr(0x70);
          if(suntaek==0)
            xy_puts(5,25,"뭼  젌챹 왩,썖,防,育        ");
          else if(suntaek==1)
            xy_puts(5,25,"뭼  칙챹 윊太 젌챹 줲 쩠 첐챲핎.");
          else if(suntaek==2)
            xy_puts(5,25,"뭼  쌱 퉛擥썅 챴쾖쨬첐얙 썖       ");
          else if(suntaek==3)
            xy_puts(5,25,"뭼  牟昭쎀 척훶                   ");
            
	   normal();
	  switch ( get_key() )
	    {
	    case LEFT : textattr(0x70);
			xy_puts(x_jwapyo[suntaek], y,menu[suntaek]);
			if (suntaek==0)   suntaek = n-1;
			else              suntaek--;
                        textattr(0xcf);
			xy_puts(x_jwapyo[suntaek], y,menu[suntaek]);
			normal();
			break;
            case RIGHT: textattr(0x70);
			xy_puts(x_jwapyo[suntaek], y,menu[suntaek]);
			if (suntaek==n-1) suntaek = 0;
			else              suntaek++;
                        textattr(0xcf);
			xy_puts(x_jwapyo[suntaek], y,menu[suntaek]);
			normal();
			break;
	    case DOWN : if (flag[0] == 'D')
			    return (suntaek);
			putch('\a');
			break;
            case CR   : normal(); return suntaek;
            case ESC  : set_cursor(12,13); normal(); return  -1    ;
            default   :  break;
	    }
	}
    }

/******************************************************************/
/* 대화상자를 표시하고 data[i].str의 값을 입력받는다              */
/* 함수값 : 정상종료=>1,  Esc 키로 종료=>-1                       */
/* (x, y) : 대화상자 시작점, n : 데이터 갯수, pok : 데이터 최대폭 */
/******************************************************************/
#define  MSG_POK  18          /* 메세지의 폭                      */

struct  daehwa {              /* 대화상자내에서의 입출력용 구조체 */
	char   *msg;          /*                    표시할 메세지 */
	char    str[30];      /*                  입력받을 데이터 */
      };
/*----------------------------------------------------------------*/
int dialog_box(int x,int y,int n, int pok, struct daehwa *data)
    {
    int     wichi   = 0;   /* 커서가 위치한 필드 번호(0,1,...n-1) */
    int     munjasu = 0;   /* 데이터 입력 필드에 입력된 문자수    */
    char    buf[4000];     /* 대화상자 부분의 이전 내용 보관용    */
    int     i, key;

    /* 대화상자로 사용할 사각형 내부의 종전 내용을 보관 */
    gettext(x,y, x+MSG_POK+pok+5,y+n*2+6, buf);

    /* 대화상자로 사용할 사각형 내부만을 지운다 */
    window( x,y, x+MSG_POK+pok+5,y+n*2+6);
    normal(); clrscr();
    window( 1,1, 80,25);

    /* 대화상자를 표시 */
    form_window(x,y, x+MSG_POK+pok+5, y+n*2+6, n*2+2, "데이터입력");
    xy_puts(x+2+pok/2, y+n*2+3, "커서 이동 : 화살표 키");
    xy_puts(x+2+pok/2, y+n*2+4, "입력 종료 : Enter  키");
    xy_puts(x+2+pok/2, y+n*2+5, "실행 취소 : Esc    키");

    for (i=0 ; i<n ; i++)             /* 메세지 / 입력 필드  표시 */
	{
	xy_puts(x+4, y+2+i*2, data[i].msg);
	set_attrib(x+MSG_POK, x+MSG_POK+pok-1, y+2+i*2, 0x70);
	}

    /* 데이터를 입력받는다 */
    gotoxy(x+MSG_POK, y+2);
    reverse();  set_cursor(12,13);
    while( 1 )
	{
	key = get_key();
	switch ( key )
	    {
	    case UP    : if (wichi==0)     wichi=n-1;  else wichi--;
			 gotoxy(x+MSG_POK, y+2+wichi*2);
			 munjasu=0;
			 break;
	    case DOWN  : if (wichi==n-1)   wichi=0;    else wichi++;
			 gotoxy(x+MSG_POK, y+2+wichi*2);
			 munjasu=0;
			 break;
	    case RIGHT : if (munjasu<pok)
			     gotoxy(wherex()+1, wherey()),munjasu++;
			 break;
	    case LEFT  : if (munjasu>0)
			     gotoxy(wherex()-1, wherey()),munjasu--;
			 break;
	    }
        if (key==ESC)
	    {
	    puttext(x,y, x+MSG_POK+pok+5,y+n*2+6, buf);
	    normal(); return -1;
	    }
	if (key==CR)
	    {
	    if (wichi == n-1)
		break;
	    else
		{
		wichi++, munjasu=0,
		gotoxy(x+MSG_POK, y+2+wichi*2);
		}
	    }
	if (key!=CR && key!=UP && key!=DOWN && key!=LEFT && key!=RIGHT)
	    {
	    munjasu++;
	    if (munjasu>pok) putch('\a');
	    else             putch(key);
	    }
	}
    normal();

    /* 입력한 데이터를 화면상에서 추출 */
    for (i=0 ; i<n ; i++)
	xy_vgets(x+MSG_POK,y+2+i*2, pok, data[i].str);

    /* 대화상자 부분의 원래의 내용을 복원 */
    puttext(x,y, x+MSG_POK+pok+5,y+n*2+6, buf);
    return 1;
    }
