                                                                정영덕 (wd40)

게임을 만드시는데 필요한 약간의 기술들입니다.  물론 다 아시는 분도 계시겠지만, 
혹 잘모르시는 분은 많은 참고가 되었으면 합니다. 제가 알고있는것을 참조함으로서 
그것을 알기위해서  드는 노력을 줄이고 다른것을  연구함으로서 시간절약과 개발에 
도움이 되었으면 합니다.

먼저 게임을 만들기 위해서 알아야 할것을 두부분으로 나눌수가 있겠읍니다.
첫번째로 입력 부분입니다. 입력장치는  키보드, 조이스틱, 마우스등 여러가지가 있
으나, 키보드로 부터의 입력에 대하여 설명하겠읍니다.
키보드로 부터의 입력은  각종 언어가 기본적인 내장함수를  가지고 있으나, 게임에 
응용하기에는 기능이 부족합니다.  즉 게임에서 좌측 키보드를  누르고 있으면 계속 
왼쪽으로 가고 중간에 총알 발사 키이를  누르면 총알이 나가는등 이러한 기능은 내
장함수나 바이오스 콜로 할 수가없으므로  보통 게임에서는 키보드의 인터럽트 루틴
을 가로채어 고유한 자신의 루틴을 수행함으로서  해결 할 수 있읍니다. IBM의 키보
드는 키이가 눌러졌을때와 떨어졌을때 인터럽트 9H를 발생시킵니다.

 떨어진 상태 -----+           +------+      +--------+        +----
                  |           |      |      |        |        |
 눌러진 상태      +-----------+      +------+        +--------+
                  |           |      |      |        |        |
                  +-----------+------+---+--+--------+--------+
                                상태가 변화될때 인터럽트 발생

인터럽트 루틴안에서는 어떤 키이가  눌러졌는지 떨어졌는지 알기위해서는 포트번호 
60H 을 읽으면 됩니다. 씨 언어에서 키이값 = inportb(0x60)하면 됩니다.
읽혀진 데이타는 8 비트인데 최상위 비트는 키이가 눌러졌는지 떨어졌는지를 나타내
는 비트입니다. 하위 0-6 비트는 키이보드 고유의 스켄코드로 되어있읍니다. 즉 128
가지의 스켄코드가 사용되는데, 보통 쓰는  키보드는 101키이 이므로 남는것들은 사
용하지 않게됩니다. 이렇게 인터럽트  루틴을 가로체어 사용하게되면 일반적인 키보
드 입력과 달리  얻게되는 정보가 아스키 코드가 아니므로  글자 입력이나 일반적인 
입력에는 약간 불편함이 생기게 된다. 그러므로 보통 인터럽트 루틴 끝에 원래의 인
터럽트 루틴을 다시 불러줌으로서  글자입력이나 일반적인 입력에는 getch()등 보통 
내장함수 루틴을 사용할 수 있게 된다.

     inp(0x60)
     +--+-------------------+
     |b7|    b6   -    b0   |  b6-b0 은 키보드 스켄코드
     +--+-------------------+
     만약 키이보드가 눌러졌으면  b7 은 0
          키이보드가 떨어졌으면  b7 은 1

    키이보드 스켄코드와 대응되는 키이
    +---------+------+------+------+------+------+------+------+------+
    |Scan Code| 0   0|10  16|20  32|30  48|40  64|50  80|60  96|70 112|
    +---------+------+------+------+------+------+------+------+------+
    |    0    |      |   Q  |   D  |   B  |  F6  |DW Arr|      |      |
    |    1    |  ESC |   W  |   F  |   N  |  F7  | PgDn |      |      |
    |    2    |   1  |   E  |   G  |   M  |  F8  |Insert|      |      |
    |    3    |   2  |   R  |   H  |   ,  |  F9  |Delete|      |      |
    |    4    |   3  |   T  |   J  |   .  |  F10 |      |      |      |
    |    5    |   4  |   Y  |   K  |   /  | NumL |      |      |      |
    |    6    |   5  |   U  |   L  |RShift| ScrL |      |      |      |
    |    7    |   6  |   I  |   ;  |      | Home |      |      |      |
    |    8    |   7  |   O  | Enter|  Alt |UP Arr|      |      |      |
    |    9    |   8  |   P  | Ctrl | Space| PgUp |      |      |      |
    |    A  10|   9  |   [  |LShift| CapsL|      |      |      |      |
    |    B  11|   0  |   ]  |   \  |  F1  |LF Arr|      |      |      |
    |    C  12|   -  |      |   Z  |  F2  |      |      |      |      |
    |    D  13|   =  |      |   X  |  F3  |RG Arr|      |      |      |
    |    E  14|BackSP|   A  |   C  |  F4  |      |      |      |      |
    |    F  15|  TAB |   S  |   V  |  F5  | End  |      |      |      |
    +---------+------+------+------+------+------+------+------+------+

아이비엠 키보드 하드웨어의 한계로서 어느 특정 키이를 두개 동시에 누르면 나머지 
키이의 입력이 작동하지 않는다.

예제 프로그램 keyboard.c 프로그램을 참조하세요

출력 부분으로서, 현재의 게임에서는 고속 그래픽 출력과 화려한 사운드의 출력등을 
들 수가 있읍니다. 제가 아는것은 브가의 고속 그래픽 출력 일부분과 피시 스피커와 
코복스로의 음성 출력부분입니다. 애드립이나  사운드 블래스터를 이용한 음악,음성 
출력은 소스는 가지고 있으나 중요  부분이 라이브러리와 오브젝트 화일로 되어있어
서 저도 지금 분석중이며 분석이되면 다시 프로그램을 짜서 공개하겠읍니다.

먼저 음성 출력부분에 대하여 설명하겠읍니다. 여기서는 작곡이나 음악 제작이 아닌 
음성을 출력 시키는 법에 대하여 설명을 하겠읍니다.

배경음악을 출력시키기 위해서는 게임프로그램과 별개로 음악 연주 프로그램이 작동
해야 합니다. 이것은 IBM PC의 타이머 인터럽트 루틴을 가로체어 사용함으로서 가능
합니다. IBM PC에는 타이머 칩이 있어서  적당한 주기를 우리가 세팅하면 그 주기마
다 인터럽트 8H가  수행되게 됩니다. 보통의 주기는  1/18.2초이며 이시간 간격으로 
인터럽트 8H가 수행되는데, 보통 이  인터럽트 루틴에서는 내장 시계의 초를 증가시
키는 기능만을 수행합니다. 1/18.2 마다  수행되므로 대략 18번에 한번씩 초를 증가 
시키면 됩니다. 만약 새로운 인터럽트  루틴으로 8H를 가로채면 밖에서 보기에는 두
가지 루틴이 동시에 수행되는 것처럼  보입니다. 이것을 이용하여 이 인터럽트 루틴
에서  배경음악이나  음성을  출력하는 것입니다.  음성이나  배경  음악출력시에는 
1/18.2초마다 인터럽트가 걸리면 그간격이 너무 길어서 자세한 음제어를 할 수 없으
므로 내부 타이머  칩을 조정하여 그주기를 짧게합니다.  인터럽트 주기는 타이머칩 
8254를 조정함으로서 가능합니다. 타이머칩 8254는  3 개의 16 bit 카운터가 내장되
어있어 타이머 인터럽트나 DMA, 스피커 tone발생에 쓰이게 됩니다.
8254 타이머 칩은 I/O번지 0x40-0x43까지 할당 되어있읍니다.

   타이머 카운터 Channel 0 : 타이머 인터럽트 0x8 발생
   타이머 카운터 Channel 1 : DMA로 DRAM refresh
   타이머 카운터 Channel 2 : 스피커 tone 주파수 설정

   8254 타이머칩 I/O 번지
   0x40 : channel 0 Data ( Read & Write )
   0x41 : channel 1 Data ( Read & Write )
   0x42 : channel 2 Data ( Read & Write )
   0x43 : 8254 타이머칩 조정 번지

타이머칩을 조정하는 방법은 다음과 같읍니다.
먼저 타이머칩  조정 번지에 우리가  하고자하는 명령을 써준후 각  channel에 해당  
하는 번지에 데이타를 쓰면 됩니다.

   8254 타이머칩 명령어 형태

    7   6 5    4 3   1    0
   +-----+------+-----+------+
   |  SC |  RWM |  TM |  BCD |
   +-----+------+-----+------+

   SC  : Select Counter 2 bit
         00 : 카운터 0 을 선택한다.
         01 : 카운터 1 을 선택한다.
         10 : 카운터 2 을 선택한다.
         11 : Read Back Command

   RWM : Read/Write Mode
         00 : 현재 카운터 값을 래치시킨다.
         01 : 카운터 하위 바이트를 읽거나 쓴다.
         10 : 카운터 상위 바이트를 읽거나 쓴다.
         11 : 카운터 하위,상위 바이트순으로 읽거나 쓴다.

   TM  : 타이머 펄스 형태
         000 : Interrupt on Terminal Count     H     +---------------------
                                               L-----+
         001 : Hardware Retriggerable One-shot

         X10 : Rate Generator                  H-----++------++------++----
               ( use Timer Interrupt )         L     ++      ++      ++
         X11 : Square Wave Mode                H     +---+   +---+   +---+
               ( use speaker tone generate )   L-----+   +---+   +---+   +-
         100 : Software triggered Strobe
         101 :

   BCD : 이진 카운터나 십진 카운터로 세팅
         0 : 이진 카운터로 동작
         1 : 십진 카운터로 동작

타이머칩 8254는 클럭 주파수가 1193180Hz입니다. 16비트 카운터로 분주하므로 인터
럽트의 최대 최소 주기는 다음과 같읍니다.

     최소주기 = 1/1193180 = 0.838 마이크로초
     최대주기 = 65536/1193180 = 1/18.2 초 = 54.9 밀리초
     주파수 개념으로 18.2Hz 에서 1193180Hz 까지 가능합니다.

그러면 타이머 인터럽트 8H 주기를 빠르게  하고 싶으면 8254 타이머칩 타이머 0 의 
값을 바꾸면 됩니다.  이값을 바꾸기 위해서 먼저 8254칩에  카운터 0을 바꾸겠다는 
정보  00110100(b)를 써주고 주기에 해당하는  데이터를 카운터 채널 0 번지에 써주
면 됩니다.
     outportb(0x43,0x34) ;
     outportb(0x40,하위 데이타) ;
     outportb(0x40,상위 데이타) ;

I/O번지 0x43에 0x36을  써주는 이유는 0x34이 이진수로  00110100인데 이것은 위의 
제어 명령표를 참고하면 알수있읍니다.
원하는 주기가 T일때 써주는 데이타 값은 다음과 같은 식에 의하여 얻어집니다.
써주는 데이타값 = T * 1193180 여기서 데이타값이 2바이트로 나오므로 상위,하위로 
나누어서 써주면 됩니다.

이렇게 타이머 인터럽트 주기를 설정하고  타이머 인터럽트 루틴을 가로채어 그안에
서 음악이나 음성 출력을 하면 배경음악,음성 효과를 얻을 수 있읍니다.

코복스로 음성을 출력시키는 방법.

코복스는 매우 간단한 8비트 A/D 컨버터로서 프린터 포트에 연결하는 카드이다.
프린터 포트의 I/O 어드레스는 시스템영역에서 알수있다.

   printer Port 1 Base Address : 0x0040:0008
   printer Port 2 Base Address : 0x0040:000A
   printer Port 3 Base Address : 0x0040:000C

   LPT1 Port Address = (int *)(0x0040:0008)
   LPT2 Port Address = (int *)(0x0040:000A)
   LPT3 Port Address = (int *)(0x0040:000C)

만약 프린터 포트가 없으면 그값이 0 이다.
보통의 경우 칼라 비디오 카드의 경우 LPT1는 0x378, LPT2는 0x278
            흑백 비디오 카드의 경우 LPT1는 0x3BC 이다

단순히 이 포트에 음성 데이타를 반복적으로 써주면 소리가난다.
주의할 사항은 음성 데이타를 쓸때  샘플링된 주기만큼 지연시켜야 한다. 이것이 맞
지 않을 경우 음성이 빠르거나 늘어지는 소리가 난다.

    outportb(코복스가 연결된 프린터 포트 어드레스,음성 데이타) ;

프로그램 intvoc0.c prnvoc0.c를 참고하십시요.

VGA 화면 출력 방법
* Advanced progrmer's guide to EGA,VGA에 자세히 잘나옵니다.

현재 게임에서 가장 많이 사용되는 그래픽  모드는 VGA 320x200 256 컬러 모드이다. 
이 모드는 바이오스 콜을 수행함으로서 세팅할 수 있으나, 바이오스 콜로 세팅된 이 
모드는 page가 1개  뿐인 packed mode로 동작하게 된다. 표준  VGA 의 RAM이 256K인 
것을 감안할때 나머지 192K는 사용되지 않는  것이다. 그래픽 페이지가 1개 뿐인 경
우에는 다중 페이지를 이용한 animation이나 기타 스프라이트를 이용한 움직임을 표
현할때는 상당히 어렵게된다.
그러나 이  모드에 약간의 VGA 내부  레지스터 값을 변경함으로서  4 page가 가능한 
plane 모드로 사용할 수 있다.
4 페이지 plane모드로 세팅하는 방법은 다음과 같다.

    mov ax,013h
    int 10h

    outport(0x3c4,0x0604) ;
    outport(0x3d4,0x0014) ;
    outport(0x3d4,0xe317) ;

VGA 화면에 그림을 그리거나 기타  작업을 하기위해서는 가장 기본이 되는것이 화면
에 한점을 찍는것이다. VGA화면에 한점을  찍는것은 그화면의 화소 좌표에 대응되는 
비디오램 어드레스에 데이타를 쓰는것과 같다. VGA의 비디오램의 어드레스는 IBM PC
의 어드레스 영역 A000:0000 - A000:FFFF에 64K 로 할당되어있다. 320*200 256 컬러 
모드의 경우 한 화면이 64000  바이트이므로 1536바이트는 사용하지 않게된다. 4 페
이지 plane모드인 경우 페이지가 4개 이므로 총 용량이 64000*4 가되어 할당된 어드
레스를 넘는데, 이것은 다음과 같은 화소대 어드레스 mapping으로 해결된다.
        A000:0000  A000:0001
 좌표 (0,0)                                                       좌표 (319,0)
     +--+--+--+--+--+--+--+--+-----------------+--+--+--+--+--+--+--+--+
     +--+--+--+--+--+--+--+--+-..............--+--+--+--+--+--+--+--+--+
     +--+--+--+--+--+--+--+--+-..............--+--+--+--+--+--+--+--+--+
     +--+--+--+--+--+--+--+--+-----------------+--+--+--+--+--+--+--+--+

좌표 (0,0) 에 점을 찍는 방법은  다음과 같다. 좌표 (0,0)의 어드레스는 A000:0000 
이므로 여기에  값을 써주게되면  된다. 여기서 1  페이지 packed mode와  4 페이지 
plane모드의 차이점을 볼수있다. 즉 plane  모드에서는 한점을 찍으면 결과적으로 4 
점이 찍히는 효과를  나타내므로 위에서 말한 할당된 어드레스의  부족을 해결할 수 
있다. 그러면 4 페이지 plane모드에서 한점만을 찍는것이 불가능한가 ? 이것은 물론 
그렇지 않다.
한점만을 찍기위해서는 VGA 내부레지스터를 바꿈으로서 가능하다. VGA내부 레지스터
에 plane mask 레지스터가 있는데, 이값을 바꾸어 줌으로서 가능하다.
plane mask 레지스터의  하위 4 비트가 이것을 결정한다.  디폴트값은 0F이다. 만약 
이 값을 0x6으로  세팅하고 좌표 (0,0)에 한점을 찍으면  결과적으로 좌표 (0,2) 에 
찍은것과  똑같은  효과를 나타낸다.  즉  4  페이지  plane모드에서는 plane  mask 
register와 비디오램에 쓰기를 이용하여 그림을 그리거나 기타 작업을 수행할 수 있
다. 4 페이지 plane모드에서는 한점을 찍기위해서 plane mask 레지스터 값을 변경하
는등 번거로운 작업으로 속도가 저하될수 있으나, 반대로 한화면을 지우는 루틴이나 
같은 색으로 칠하는 루틴등은 4배 빠르게 만들 수 있다.
그러면 페이지가 4 개있는데 현재 화면에 보이는 페이지를 바꾸는 방법은 다음과 같
다. 이것은 VGA내부의 start address register의 값을 바꾸면된다.
이값을 바꾸는데 주의할점은 아무때나 바꾸면 화면이 껌벅거릴수 있으므로 VGA가 화
면을 갱신하는 순간에 바꾸어야한다.
start address 레지스터  값에 따라 화면에 보여주는 비디오램  영역이 틀려지게 된
다. 이값을 적당히 바꿈으로서 하드웨어 스크롤이나 다중페이지 기법을 사용하여 화
면의 껌벅거림이 없는 animation을 수행할 수  있다. 다중 페이지 기법은 아주 간단
하다. 페이지 0을  화면에 보여준 상태에서 다음에 보여줄 그림을  페이지 1에 그리
고, 다 그린 다음 페이지 1을  보여주면 순간적으로 그림이 바뀌기 때문에 껌벅거림
이 없이 느껴지게 된다.

  보여주는 페이지 :   0  --->  1  --->  0  --->  1  --->  0
  작업     페이지 :   1  --->  0  --->  1  --->  0  --->  1

이러한 순서로 계속 진행하면 된다.

4 페이지 평면  모드는, 한 pixel이나 그림을  그리기위해서 plane mask register를 
변경함으로서 속도가 저하되나, 일반적인  아케이드 게임에서는 상당한 속도의 스크
롤이나 움직임을 보여주는데,  이것은 VGA 특성중의 하나인 쓰기  모드 변경에 의한 
것이다. VGA에는 쓰기모드가 4 가지  있는데, 보통의 상테에서는 쓰기모드 0 으로서 
IBM PC host memory에서 VGA Video RAM으로 전송하는 모드이다. 고속으로 그림을 그
리기 위해서 쓰기 모드 1을 사용하는데,  이것은 고속인 대신에 VGA video RAM 에서 
video RAM 사이의 전송에만 쓸수 있다는 단점이 있다. 이것을 교묘히 잘이용하면 고
속의 스크롤을 할 수있게된다.
